<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><link rel="icon" href="/blog/favicon.ico"/><title>SemVer</title><meta name="robots" content="index,follow"/><meta name="googlebot" content="index,follow"/><meta name="description" content="Personal Knowledge Space"/><meta property="og:title" content="SemVer"/><meta property="og:description" content="Personal Knowledge Space"/><meta property="og:url" content="https://dustinbarnes.github.io/blog/notes/semver/"/><meta property="og:type" content="article"/><meta property="article:published_time" content="3/25/2023"/><meta property="article:modified_time" content="3/25/2023"/><link rel="canonical" href="https://dustinbarnes.github.io/blog/notes/semver/"/><meta name="next-head-count" content="14"/><link rel="preload" href="/blog/_next/static/css/0884cc5025e90402.css" as="style"/><link rel="stylesheet" href="/blog/_next/static/css/0884cc5025e90402.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/blog/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/blog/_next/static/chunks/webpack-e6501809440c92fa.js" defer=""></script><script src="/blog/_next/static/chunks/framework-28c999baf2863c3d.js" defer=""></script><script src="/blog/_next/static/chunks/main-718fd100d66b9b0a.js" defer=""></script><script src="/blog/_next/static/chunks/pages/_app-db620eca7e43bfd8.js" defer=""></script><script src="/blog/_next/static/chunks/935-4dee79e80b8641c6.js" defer=""></script><script src="/blog/_next/static/chunks/6-50972def09142ee2.js" defer=""></script><script src="/blog/_next/static/chunks/pages/notes/%5Bid%5D-78d472fa3b924116.js" defer=""></script><script src="/blog/_next/static/e3auSERhnLAKuEr6XRDIR/_buildManifest.js" defer=""></script><script src="/blog/_next/static/e3auSERhnLAKuEr6XRDIR/_ssgManifest.js" defer=""></script></head><body><div id="__next" data-reactroot=""><section class="ant-layout" style="width:100%;min-height:100%"><header class="ant-layout-header" style="position:fixed;isolation:isolate;z-index:1;width:100%;border-bottom:1px solid #d4dadf;height:64px;padding:0 24px 0 2px"><div class="ant-row ant-row-center" style="max-width:992px;justify-content:space-between;margin:0 auto"><div style="display:flex" class="ant-col ant-col-xs-20 ant-col-sm-4"></div><div class="ant-col gutter-row ant-col-xs-0 ant-col-sm-20 ant-col-md-20 ant-col-lg-19"><div class="ant-select ant-select-lg ant-select-auto-complete ant-select-single ant-select-allow-clear ant-select-show-search" style="width:100%"><div class="ant-select-selector"><span class="ant-select-selection-search"><input type="search" autoComplete="off" class="ant-select-selection-search-input" role="combobox" aria-haspopup="listbox" aria-owns="undefined_list" aria-autocomplete="list" aria-controls="undefined_list" aria-activedescendant="undefined_list_0" value=""/></span><span class="ant-select-selection-placeholder">For full text search please use the &#x27;?&#x27; prefix. e.g. ? Onboarding</span></div></div></div><div style="display:none;align-items:center;justify-content:center" class="ant-col ant-col-xs-4 ant-col-sm-4 ant-col-md-0 ant-col-lg-0"><span role="img" aria-label="menu" style="font-size:24px" tabindex="-1" class="anticon anticon-menu"><svg viewBox="64 64 896 896" focusable="false" data-icon="menu" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M904 160H120c-4.4 0-8 3.6-8 8v64c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-64c0-4.4-3.6-8-8-8zm0 624H120c-4.4 0-8 3.6-8 8v64c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-64c0-4.4-3.6-8-8-8zm0-312H120c-4.4 0-8 3.6-8 8v64c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-64c0-4.4-3.6-8-8-8z"></path></svg></span></div></div></header><section class="ant-layout" style="margin-top:64px;display:flex;flex-direction:row"><div class="site-layout-sidebar" style="flex:0 0 auto;width:calc(max((100% - 992px) / 2, 0px) + 200px);min-width:200px;padding-left:calc((100% - 992px) / 2)"><aside class="ant-layout-sider ant-layout-sider-dark" style="position:fixed;overflow:auto;height:calc(100vh - 64px);background-color:transparent;flex:0 0 200px;max-width:200px;min-width:200px;width:200px"><div class="ant-layout-sider-children"></div></aside></div><main class="ant-layout-content side-layout-main" style="max-width:1200px;min-width:0;display:block"><div style="padding:0 24px"><div class="main-content" role="main"><div class="ant-row"><div class="ant-col ant-col-24"><div class="ant-row" style="margin-left:-10px;margin-right:-10px"><div style="padding-left:10px;padding-right:10px" class="ant-col ant-col-xs-24 ant-col-md-18"><div><h1 id="semver">SemVer<a aria-hidden="true" class="anchor-heading icon-link" href="#semver"></a></h1>
<h1 id="semver-pros-and-cons">SemVer: Pros and Cons<a aria-hidden="true" class="anchor-heading icon-link" href="#semver-pros-and-cons"></a></h1>
<p>SemVer is a great theoretical idea. However, there are some issues</p>
<h2 id="semver-in-theory">SemVer: In Theory<a aria-hidden="true" class="anchor-heading icon-link" href="#semver-in-theory"></a></h2>
<p>SemVer consists of 3 dot-separated numbers:</p>
<p><img src="/blog/assets/images/2023-03-24-17-31-01.png"></p>
<p>Toolchains within NodeJS, Ruby, and Python claim adherence to this. When you import a dependency, it will often show up like this: </p>
<pre class="language-json"><code class="language-json"><span class="token property">"node-tool-lib"</span><span class="token operator">:</span> <span class="token string">"^2.1.4"</span>
</code></pre>
<p>With this specification, you can pick up a version of <code>node-tool-lib</code> from <code>2.1.4</code> to <code>&#x3C; 3.*.*</code>. So long as the authors maintain the SemVer conventions, it should be safe to upgrade at any time. </p>
<h2 id="the-contract-problem">The Contract Problem<a aria-hidden="true" class="anchor-heading icon-link" href="#the-contract-problem"></a></h2>
<p>SemVer is designed to be used as an indicator of compatibility and functionality; the numbers have rigid meanings. The argument goes that a major release is the only time backwards-incompatible changes are made, thus indicating safety in upgrading the minor- and patch-level as available. But this means that multiple things need to be true at the same time:</p>
<ol>
<li>You have a well-defined contract, and a well-defined place that contract is applied</li>
<li>You are able to enforce the contract through programatic means, such as testing</li>
<li>You absolutely must bump the major version on an incompatibility, no matter how slight</li>
<li>The major version number is only incremented programmatically based upon your contract</li>
</ol>
<p>Now, almost nobody has (1) and (2) -- and no, JSON Schema validation is not sufficient for this purpose. Contracts are not just the shape of the data, but also the required order of operations as well as the exceptional code paths. Item (3) is a critical feature we'll discuss in a moment, but item (4) is how you maintain compatible with SemVer. No human developer is perfect. If we rely on humans to decide what constitutes a breaking change, we will invariably end up in a situtation where a developer thought they fixed a small bug, only bumped the patch, but actually introduced a new bug that wasn't caught by the automated testing framework.</p>
<h2 id="the-cicd-problem">The CI/CD Problem<a aria-hidden="true" class="anchor-heading icon-link" href="#the-cicd-problem"></a></h2>
<p>Using SemVer-based ranges for dependencies means that your build process is not strictly repeatable. It depends upon the availability of updates to your dependencies, thus dependent upon time of day that the build is executed. Old code that previously worked with thorough testing may no longer work if built a few days later. This happens because some developers aren't as strict with their SemVer as they should be. Other developers decided they didn't like SemVer, and refused to be bound by it. <a href="https://github.com/jashkenas/underscore/issues/1805">You can guess how that went</a>. Lockfiles are a poor band-aid for a "design feature". One thing I insist on in my projects is that every version is exactly pinned. No SemVer ranges, no `-SNAPSHOT` dependencies, etc. In NPM, one can enforce this with the `--save-exact` flag when running `npm install`.</p>
<h3 id="zero-dot">Zero-Dot<a aria-hidden="true" class="anchor-heading icon-link" href="#zero-dot"></a></h3>
<p>So what is a <code>0.y.z</code> release? SemVer tells us that: </p>
<blockquote>
<p>Major version zero (0.y.z) is for initial development. Anything may change at any time. The public API should not be considered stable  </p>
<ul>
<li><a href="https://semver.org/#spec-item-4">https://semver.org/#spec-item-4</a></li>
</ul>
</blockquote>
<p>Thus, if a dev depends on package 0.y.z in a SemVer range, you should plan on receiving breaking changes. That's not very helpful. How many projects sit out there at 0.y.z forever? </p>
<p>In a strictly pedantic sense, you can't claim to do SemVer until you have a 1.y.z release. 0.y.z releases are just a beginning state, not a public availability state. </p>
<h2 id="what-does-compatibility-mean">What does Compatibility Mean<a aria-hidden="true" class="anchor-heading icon-link" href="#what-does-compatibility-mean"></a></h2>
<p>Notice in most large nodejs repositories, authors pin their dependencies to exact versions. This is to get away from the problems that SemVer introduced. </p>
<p>Pop quiz: How are devs bumping the major version number? Remember what SemVer says:</p>
<blockquote>
<p>Major version X (X.y.z | X > 0) MUST be incremented if any backwards incompatible changes are introduced to the public API.  </p>
<ul>
<li><a href="https://semver.org/#spec-item-8">https://semver.org/#spec-item-8</a></li>
</ul>
</blockquote>
<p>To answer this effectively, we must strictly define what constitutes compatibility. Earlier in the document, this is what they say about the patch-level version:</p>
<blockquote>
<p>Patch version Z (x.y.Z | x > 0) MUST be incremented if only backwards compatible bug fixes are introduced. A bug fix is defined as an internal change that fixes incorrect behavior.  </p>
<ul>
<li><a href="https://semver.org/#spec-item-6">https://semver.org/#spec-item-6</a></li>
</ul>
</blockquote>
<p>This sentiment is intuitive and obvious. However, remember that we are saying that those who depend on us may automatically upgrade safely in the patch-level. </p>
<p>SemVer declares the public API as what you're versioning. Let's imagine, however, that there's a change to your 500 error response. Instead of just sending a JSON document like below:</p>
<p><code>{ "error": "500", "cause": "Some error occurred"}</code></p>
<p>Then, you want to enhance the output to also include a tracing id that can be used for later analysis:</p>
<p><code>{ "error": "500", "cause": "Some error occurred", "trace": "13eb8a9"}</code></p>
<p>This, by definition, breaks the output contract, right? Or, did your contract specify that clients should accept all new fields? The default behavior on extra fields changes between libraries. Some throw exceptions, others silently swallow the extra data. Thus, what "backwards compatible" means is specific to the implementers of your API. </p>
<p>Arguably, any change in outputs from the universe of inputs is a public-facing, non-backwards-compatible change. Thus simply adding this field to your outputs constitutes a major version bump. Without tools specifically designed to enforce the contracts, you may never know if a major bump was needed.</p>
<p>This therefore usually leaves to humans who decide that a bump is needed, based on some abstract concept of compatibility. Without a strict compatibility test, this process will fail, given enough time.</p>
<h2 id="your-major-version-sucks">Your Major Version Sucks<a aria-hidden="true" class="anchor-heading icon-link" href="#your-major-version-sucks"></a></h2>
<p>So you're all-in on SemVer. You have your contracts, you have your contract tests, you have a CI system that can divine the major/minor/patch-level changes. Now, you're faced with a new problem: You will invariably be bumping your major version far more than most folks would like. You should be expecting a major version with 3 or 4 digits. NVidia's graphics drivers are relatively famously large-versioned (but strictly not SemVer). At the time of writing, the latest driver was version `417.21`. Without a patch level, however, this is not SemVer.</p>
<p>This leads to two schools of thought. Some folks claim that the major version is more of a marketing/effort construct, and that you can do SemVer with just the last two digits. Again: this isn't SemVer. SemVer's primary rule, in my opinion, is that the major version number indicates compatibility.</p>
<p>Others think that it's fine to continually bump the major version number, and there's no big issue with having major version numbers in the hundreds (`339.0.1`) or thousands (`1317.3.19`). I argue that this is actually the only true version of SemVer. However, this assumes that you have the contracts in place and verified. Not only is it not enough for a developer to make a judgement call, having a human bump the major version is not strictly SemVer.</p>
<p>The sad reality is, most who claim to be doing SemVer aren't doing SemVer. They don't actually have their compatibility contracs being enforced, much less even existing. Without a non-human arbiter of truth, this SemVer-lite is just another iteration of manual versioning, but with a lot more risk for downstream dependencies due to the implied safely</p>
<h2 id="compatibility-effort">Compatibility Effort<a aria-hidden="true" class="anchor-heading icon-link" href="#compatibility-effort"></a></h2>
<p>So given my assertion that the only folks who truly do SemVer will necessarily have major version numbers that grow much larger than most are used to, what is the benefit of SemVer? Yes, you can say you want `113.x.x` and probably get the right thing. However, how do we know how much effort it will take for downstream dependencies to update major versions? In a project with traditional versioning, I know that going from version 2 to version 3 will mean big changes, possibly some code fixes, possibly complete re-workings of parts of my codebase. With SemVer, this level of change is at the same level as a small bug fix or inconsequential data shape change.</p>
<p>Downstream users then have to go through and look at all the major version bumps, and actually read the release notes, for potentially hundreds or thousands of major versions, and determine what adaptations are needed in their code.</p>
<h2 id="the-cicd-alternative">The CI/CD Alternative<a aria-hidden="true" class="anchor-heading icon-link" href="#the-cicd-alternative"></a></h2>
<p>While some developers have taken to what has been humorously called [Sentimental Versioning](<a href="http://sentimentalversioning.org/%5C">http://sentimentalversioning.org/\</a>). Basically, developers still follow the old way of the major version being a marketing construct, then try to enforce compatibility on the feature- and patch-level version. This seems inferior, but it also gives downstream users a conceptual idea of how big the change is. When Angular went from Angular 2 to Angular 4, it was a clear message to the community that *this new thing is really different*. There's an explicit declaration of integration efforts. I can be relatively certain that `2.0.1` and `2.0.10` will *probably* be interchangeable. But it's not guaranteed through an automated, robotic means, and thus building your product around auto-upgrading SemVer ranges introduces surface area for tricky regressions.</p>
<p>My preferred versioning scheme is specific to CD pipelines, but as a proponent of CI/CD, I think you should adopt it anyway! So in this world, we don't care about major-minor-patch. We're just delivering iterations of the same product. We have an integration environment for the specific purpose of testing with dependencies. In this case, all that really matters is that you have a unique version for your automated deployments to use. In my preference, the version is exactly the build number in the CI system of your choice. This has some nice side effects: You can immediately tie a version back to the build that created it; The number is monotonically increasing, indicating directionality of progress. Another potential is to simply use the git hash of the commit as your version. While this can work with tools, it doesn't really indicate directionality of progress nor does it indicate which build is newer without additional metadata.</p>
<hr>
<strong>Children</strong>
<ol>
<li><a href="/blog/notes/promise-of-semver">Promise of SemVer</a></li>
<li><a href="/blog/notes/semver-purpose">Purpose of SemVer</a></li>
<li><a href="/blog/notes/g19cobmk3lnn50wk095xqeg">SemVer Breaking Changes</a></li>
<li><a href="/blog/notes/requirements-for-semver">SemVer Requirements</a></li>
</ol>
<hr>
<strong>Backlinks</strong>
<ul>
<li><a href="/blog/notes/software-versioning">Versioning</a></li>
</ul></div></div><div style="padding-left:10px;padding-right:10px" class="ant-col ant-col-xs-0 ant-col-md-6"><div><div class=""><div class="ant-anchor-wrapper dendron-toc" style="max-height:calc(100vh - 64px);z-index:1"><div class="ant-anchor"><div class="ant-anchor-ink"><span class="ant-anchor-ink-ball"></span></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#semver-pros-and-cons" title="SemVer: Pros and Cons">SemVer: Pros and Cons</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#semver-in-theory" title="SemVer: In Theory">SemVer: In Theory</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#the-contract-problem" title="The Contract Problem">The Contract Problem</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#the-cicd-problem" title="The CI/CD Problem">The CI/CD Problem</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#zero-dot" title="Zero-Dot">Zero-Dot</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#what-does-compatibility-mean" title="What does Compatibility Mean">What does Compatibility Mean</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#your-major-version-sucks" title="Your Major Version Sucks">Your Major Version Sucks</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#compatibility-effort" title="Compatibility Effort">Compatibility Effort</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#the-cicd-alternative" title="The CI/CD Alternative">The CI/CD Alternative</a></div></div></div></div></div></div></div></div></div></div></div><div class="ant-divider ant-divider-horizontal" role="separator"></div><footer class="ant-layout-footer" style="padding:0 24px 24px"></footer></main></section></section></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"note":{"id":"semver","title":"SemVer","desc":"","updated":1679705114196,"created":1679703793652,"custom":{},"fname":"tech.philosophy.versioning.semver","type":"note","vault":{"fsPath":".","selfContained":true,"name":"Dendron"},"contentHash":"5e978ecf178c0123ecae12153d3df923","links":[{"from":{"fname":"tech.philosophy.versioning","id":"software-versioning","vaultName":"Dendron"},"type":"backlink","position":{"start":{"line":23,"column":4,"offset":1101},"end":{"line":23,"column":41,"offset":1138},"indent":[]},"value":"tech.philosophy.versioning.semver"}],"anchors":{"semver-pros-and-cons":{"type":"header","text":"SemVer: Pros and Cons","value":"semver-pros-and-cons","line":8,"column":0,"depth":1},"semver-in-theory":{"type":"header","text":"SemVer: In Theory","value":"semver-in-theory","line":12,"column":0,"depth":2},"the-contract-problem":{"type":"header","text":"The Contract Problem","value":"the-contract-problem","line":26,"column":0,"depth":2},"the-cicd-problem":{"type":"header","text":"The CI/CD Problem","value":"the-cicd-problem","line":37,"column":0,"depth":2},"zero-dot":{"type":"header","text":"Zero-Dot","value":"zero-dot","line":41,"column":0,"depth":3},"what-does-compatibility-mean":{"type":"header","text":"What does Compatibility Mean","value":"what-does-compatibility-mean","line":52,"column":0,"depth":2},"your-major-version-sucks":{"type":"header","text":"Your Major Version Sucks","value":"your-major-version-sucks","line":82,"column":0,"depth":2},"compatibility-effort":{"type":"header","text":"Compatibility Effort","value":"compatibility-effort","line":92,"column":0,"depth":2},"the-cicd-alternative":{"type":"header","text":"The CI/CD Alternative","value":"the-cicd-alternative","line":98,"column":0,"depth":2}},"children":["g19cobmk3lnn50wk095xqeg","promise-of-semver","semver-purpose","requirements-for-semver"],"parent":"software-versioning","data":{}},"body":"\u003ch1 id=\"semver\"\u003eSemVer\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#semver\"\u003e\u003c/a\u003e\u003c/h1\u003e\n\u003ch1 id=\"semver-pros-and-cons\"\u003eSemVer: Pros and Cons\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#semver-pros-and-cons\"\u003e\u003c/a\u003e\u003c/h1\u003e\n\u003cp\u003eSemVer is a great theoretical idea. However, there are some issues\u003c/p\u003e\n\u003ch2 id=\"semver-in-theory\"\u003eSemVer: In Theory\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#semver-in-theory\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eSemVer consists of 3 dot-separated numbers:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/blog/assets/images/2023-03-24-17-31-01.png\"\u003e\u003c/p\u003e\n\u003cp\u003eToolchains within NodeJS, Ruby, and Python claim adherence to this. When you import a dependency, it will often show up like this: \u003c/p\u003e\n\u003cpre class=\"language-json\"\u003e\u003ccode class=\"language-json\"\u003e\u003cspan class=\"token property\"\u003e\"node-tool-lib\"\u003c/span\u003e\u003cspan class=\"token operator\"\u003e:\u003c/span\u003e \u003cspan class=\"token string\"\u003e\"^2.1.4\"\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWith this specification, you can pick up a version of \u003ccode\u003enode-tool-lib\u003c/code\u003e from \u003ccode\u003e2.1.4\u003c/code\u003e to \u003ccode\u003e\u0026#x3C; 3.*.*\u003c/code\u003e. So long as the authors maintain the SemVer conventions, it should be safe to upgrade at any time. \u003c/p\u003e\n\u003ch2 id=\"the-contract-problem\"\u003eThe Contract Problem\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#the-contract-problem\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eSemVer is designed to be used as an indicator of compatibility and functionality; the numbers have rigid meanings. The argument goes that a major release is the only time backwards-incompatible changes are made, thus indicating safety in upgrading the minor- and patch-level as available. But this means that multiple things need to be true at the same time:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eYou have a well-defined contract, and a well-defined place that contract is applied\u003c/li\u003e\n\u003cli\u003eYou are able to enforce the contract through programatic means, such as testing\u003c/li\u003e\n\u003cli\u003eYou absolutely must bump the major version on an incompatibility, no matter how slight\u003c/li\u003e\n\u003cli\u003eThe major version number is only incremented programmatically based upon your contract\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eNow, almost nobody has (1) and (2) -- and no, JSON Schema validation is not sufficient for this purpose. Contracts are not just the shape of the data, but also the required order of operations as well as the exceptional code paths. Item (3) is a critical feature we'll discuss in a moment, but item (4) is how you maintain compatible with SemVer. No human developer is perfect. If we rely on humans to decide what constitutes a breaking change, we will invariably end up in a situtation where a developer thought they fixed a small bug, only bumped the patch, but actually introduced a new bug that wasn't caught by the automated testing framework.\u003c/p\u003e\n\u003ch2 id=\"the-cicd-problem\"\u003eThe CI/CD Problem\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#the-cicd-problem\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eUsing SemVer-based ranges for dependencies means that your build process is not strictly repeatable. It depends upon the availability of updates to your dependencies, thus dependent upon time of day that the build is executed. Old code that previously worked with thorough testing may no longer work if built a few days later. This happens because some developers aren't as strict with their SemVer as they should be. Other developers decided they didn't like SemVer, and refused to be bound by it. \u003ca href=\"https://github.com/jashkenas/underscore/issues/1805\"\u003eYou can guess how that went\u003c/a\u003e. Lockfiles are a poor band-aid for a \"design feature\". One thing I insist on in my projects is that every version is exactly pinned. No SemVer ranges, no `-SNAPSHOT` dependencies, etc. In NPM, one can enforce this with the `--save-exact` flag when running `npm install`.\u003c/p\u003e\n\u003ch3 id=\"zero-dot\"\u003eZero-Dot\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#zero-dot\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eSo what is a \u003ccode\u003e0.y.z\u003c/code\u003e release? SemVer tells us that: \u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eMajor version zero (0.y.z) is for initial development. Anything may change at any time. The public API should not be considered stable  \u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://semver.org/#spec-item-4\"\u003ehttps://semver.org/#spec-item-4\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eThus, if a dev depends on package 0.y.z in a SemVer range, you should plan on receiving breaking changes. That's not very helpful. How many projects sit out there at 0.y.z forever? \u003c/p\u003e\n\u003cp\u003eIn a strictly pedantic sense, you can't claim to do SemVer until you have a 1.y.z release. 0.y.z releases are just a beginning state, not a public availability state. \u003c/p\u003e\n\u003ch2 id=\"what-does-compatibility-mean\"\u003eWhat does Compatibility Mean\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#what-does-compatibility-mean\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eNotice in most large nodejs repositories, authors pin their dependencies to exact versions. This is to get away from the problems that SemVer introduced. \u003c/p\u003e\n\u003cp\u003ePop quiz: How are devs bumping the major version number? Remember what SemVer says:\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eMajor version X (X.y.z | X \u003e 0) MUST be incremented if any backwards incompatible changes are introduced to the public API.  \u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://semver.org/#spec-item-8\"\u003ehttps://semver.org/#spec-item-8\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eTo answer this effectively, we must strictly define what constitutes compatibility. Earlier in the document, this is what they say about the patch-level version:\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003ePatch version Z (x.y.Z | x \u003e 0) MUST be incremented if only backwards compatible bug fixes are introduced. A bug fix is defined as an internal change that fixes incorrect behavior.  \u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://semver.org/#spec-item-6\"\u003ehttps://semver.org/#spec-item-6\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eThis sentiment is intuitive and obvious. However, remember that we are saying that those who depend on us may automatically upgrade safely in the patch-level. \u003c/p\u003e\n\u003cp\u003eSemVer declares the public API as what you're versioning. Let's imagine, however, that there's a change to your 500 error response. Instead of just sending a JSON document like below:\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e{ \"error\": \"500\", \"cause\": \"Some error occurred\"}\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003eThen, you want to enhance the output to also include a tracing id that can be used for later analysis:\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e{ \"error\": \"500\", \"cause\": \"Some error occurred\", \"trace\": \"13eb8a9\"}\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003eThis, by definition, breaks the output contract, right? Or, did your contract specify that clients should accept all new fields? The default behavior on extra fields changes between libraries. Some throw exceptions, others silently swallow the extra data. Thus, what \"backwards compatible\" means is specific to the implementers of your API. \u003c/p\u003e\n\u003cp\u003eArguably, any change in outputs from the universe of inputs is a public-facing, non-backwards-compatible change. Thus simply adding this field to your outputs constitutes a major version bump. Without tools specifically designed to enforce the contracts, you may never know if a major bump was needed.\u003c/p\u003e\n\u003cp\u003eThis therefore usually leaves to humans who decide that a bump is needed, based on some abstract concept of compatibility. Without a strict compatibility test, this process will fail, given enough time.\u003c/p\u003e\n\u003ch2 id=\"your-major-version-sucks\"\u003eYour Major Version Sucks\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#your-major-version-sucks\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eSo you're all-in on SemVer. You have your contracts, you have your contract tests, you have a CI system that can divine the major/minor/patch-level changes. Now, you're faced with a new problem: You will invariably be bumping your major version far more than most folks would like. You should be expecting a major version with 3 or 4 digits. NVidia's graphics drivers are relatively famously large-versioned (but strictly not SemVer). At the time of writing, the latest driver was version `417.21`. Without a patch level, however, this is not SemVer.\u003c/p\u003e\n\u003cp\u003eThis leads to two schools of thought. Some folks claim that the major version is more of a marketing/effort construct, and that you can do SemVer with just the last two digits. Again: this isn't SemVer. SemVer's primary rule, in my opinion, is that the major version number indicates compatibility.\u003c/p\u003e\n\u003cp\u003eOthers think that it's fine to continually bump the major version number, and there's no big issue with having major version numbers in the hundreds (`339.0.1`) or thousands (`1317.3.19`). I argue that this is actually the only true version of SemVer. However, this assumes that you have the contracts in place and verified. Not only is it not enough for a developer to make a judgement call, having a human bump the major version is not strictly SemVer.\u003c/p\u003e\n\u003cp\u003eThe sad reality is, most who claim to be doing SemVer aren't doing SemVer. They don't actually have their compatibility contracs being enforced, much less even existing. Without a non-human arbiter of truth, this SemVer-lite is just another iteration of manual versioning, but with a lot more risk for downstream dependencies due to the implied safely\u003c/p\u003e\n\u003ch2 id=\"compatibility-effort\"\u003eCompatibility Effort\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#compatibility-effort\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eSo given my assertion that the only folks who truly do SemVer will necessarily have major version numbers that grow much larger than most are used to, what is the benefit of SemVer? Yes, you can say you want `113.x.x` and probably get the right thing. However, how do we know how much effort it will take for downstream dependencies to update major versions? In a project with traditional versioning, I know that going from version 2 to version 3 will mean big changes, possibly some code fixes, possibly complete re-workings of parts of my codebase. With SemVer, this level of change is at the same level as a small bug fix or inconsequential data shape change.\u003c/p\u003e\n\u003cp\u003eDownstream users then have to go through and look at all the major version bumps, and actually read the release notes, for potentially hundreds or thousands of major versions, and determine what adaptations are needed in their code.\u003c/p\u003e\n\u003ch2 id=\"the-cicd-alternative\"\u003eThe CI/CD Alternative\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#the-cicd-alternative\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eWhile some developers have taken to what has been humorously called [Sentimental Versioning](\u003ca href=\"http://sentimentalversioning.org/%5C\"\u003ehttp://sentimentalversioning.org/\\\u003c/a\u003e). Basically, developers still follow the old way of the major version being a marketing construct, then try to enforce compatibility on the feature- and patch-level version. This seems inferior, but it also gives downstream users a conceptual idea of how big the change is. When Angular went from Angular 2 to Angular 4, it was a clear message to the community that *this new thing is really different*. There's an explicit declaration of integration efforts. I can be relatively certain that `2.0.1` and `2.0.10` will *probably* be interchangeable. But it's not guaranteed through an automated, robotic means, and thus building your product around auto-upgrading SemVer ranges introduces surface area for tricky regressions.\u003c/p\u003e\n\u003cp\u003eMy preferred versioning scheme is specific to CD pipelines, but as a proponent of CI/CD, I think you should adopt it anyway! So in this world, we don't care about major-minor-patch. We're just delivering iterations of the same product. We have an integration environment for the specific purpose of testing with dependencies. In this case, all that really matters is that you have a unique version for your automated deployments to use. In my preference, the version is exactly the build number in the CI system of your choice. This has some nice side effects: You can immediately tie a version back to the build that created it; The number is monotonically increasing, indicating directionality of progress. Another potential is to simply use the git hash of the commit as your version. While this can work with tools, it doesn't really indicate directionality of progress nor does it indicate which build is newer without additional metadata.\u003c/p\u003e\n\u003chr\u003e\n\u003cstrong\u003eChildren\u003c/strong\u003e\n\u003col\u003e\n\u003cli\u003e\u003ca href=\"/blog/notes/promise-of-semver\"\u003ePromise of SemVer\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"/blog/notes/semver-purpose\"\u003ePurpose of SemVer\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"/blog/notes/g19cobmk3lnn50wk095xqeg\"\u003eSemVer Breaking Changes\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"/blog/notes/requirements-for-semver\"\u003eSemVer Requirements\u003c/a\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003chr\u003e\n\u003cstrong\u003eBacklinks\u003c/strong\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"/blog/notes/software-versioning\"\u003eVersioning\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e","noteIndex":{"id":"root","title":"Dustin Barnes","desc":"","updated":1681759798693,"created":1595961348801,"custom":{"nav_order":0,"permalink":"/"},"fname":"root","type":"note","vault":{"fsPath":".","selfContained":true,"name":"Dendron"},"contentHash":"3ebb4073bdee31751a155bb33051029a","links":[],"anchors":{"dustin-barnes":{"type":"header","text":"Dustin Barnes","value":"dustin-barnes","line":8,"column":0,"depth":1}},"children":["articles","concepts","xufh3s1pjwin0pvew6jmu8j"],"parent":null,"data":{},"body":"\n# Dustin Barnes\n\nThis is my digital garden. It's not monetized, there's no analytics. It's probably not great at SEO. But it's simple, it's text-based, and it's interconnected. \n\nA few things of note: \n\n- My main GitHub profile is https://github.com/dustinbarnes\n- This blog is built from https://github.com/dustinbarnes/blog. \n  - Notice the GitHub Actions powering the publish process: https://github.com/dustinbarnes/blog/blob/main/.github/workflows/publish.yml\n- My dotfiles repo: https://github.com/dustinbarnes/dotfiles\n"},"collectionChildren":null,"customHeadContent":null,"config":{"version":5,"dev":{"enablePreviewV2":true,"enableSelfContainedVaults":true},"commands":{"lookup":{"note":{"selectionMode":"extract","confirmVaultOnCreate":true,"vaultSelectionModeOnCreate":"smart","leaveTrace":false,"bubbleUpCreateNew":true,"fuzzThreshold":0.2}},"randomNote":{},"insertNoteLink":{"aliasMode":"none","enableMultiSelect":false},"insertNoteIndex":{"enableMarker":false},"copyNoteLink":{"aliasMode":"title"},"templateHierarchy":"template"},"workspace":{"vaults":[{"fsPath":".","selfContained":true,"name":"Dendron"}],"journal":{"dailyDomain":"daily","name":"journal","dateFormat":"y.MM.dd","addBehavior":"childOfDomain"},"scratch":{"name":"scratch","dateFormat":"y.MM.dd.HHmmss","addBehavior":"asOwnDomain"},"task":{"name":"task","dateFormat":"y.MM.dd","addBehavior":"asOwnDomain","statusSymbols":{"":" ","wip":"w","done":"x","assigned":"a","moved":"m","blocked":"b","delegated":"l","dropped":"d","pending":"y"},"taskCompleteStatus":["done","x"],"prioritySymbols":{"H":"high","M":"medium","L":"low"},"todoIntegration":false,"createTaskSelectionType":"selection2link"},"graph":{"zoomSpeed":1,"createStub":false},"enableAutoCreateOnDefinition":false,"enableXVaultWikiLink":false,"enableRemoteVaultInit":true,"enableUserTags":true,"enableHashTags":true,"workspaceVaultSyncMode":"noCommit","enableAutoFoldFrontmatter":false,"enableEditorDecorations":true,"maxPreviewsCached":10,"maxNoteLength":204800,"enableFullHierarchyNoteTitle":false},"preview":{"enableFMTitle":true,"enableNoteTitleForLink":true,"enableFrontmatterTags":true,"enableHashesForFMTags":false,"enablePrettyRefs":true,"enableKatex":true,"automaticallyShowPreview":false},"publishing":{"enableFMTitle":true,"enableNoteTitleForLink":true,"enablePrettyRefs":true,"enableKatex":true,"copyAssets":true,"siteHierarchies":["root"],"writeStubs":false,"siteRootDir":"docs","seo":{"title":"Dustin Barnes","description":"Personal Knowledge Space"},"github":{"enableEditLink":true,"editLinkText":"Edit this page on GitHub","editBranch":"main","editViewMode":"tree"},"enableSiteLastModified":true,"enableFrontmatterTags":true,"enableHashesForFMTags":false,"enableRandomlyColoredTags":true,"enableTaskNotes":true,"enablePrettyLinks":true,"searchMode":"search","siteUrl":"https://dustinbarnes.github.io","assetsPrefix":"/blog","siteFaviconPath":"favicon.ico","siteIndex":"root"}}},"__N_SSG":true},"page":"/notes/[id]","query":{"id":"semver"},"buildId":"e3auSERhnLAKuEr6XRDIR","assetPrefix":"/blog","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>