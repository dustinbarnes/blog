<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><link rel="icon" href="/blog/favicon.ico"/><title>Java Release Process with Continuous Delivery</title><meta name="robots" content="index,follow"/><meta name="googlebot" content="index,follow"/><meta name="description" content="Personal Knowledge Space"/><meta property="og:title" content="Java Release Process with Continuous Delivery"/><meta property="og:description" content="Personal Knowledge Space"/><meta property="og:url" content="https://dustinbarnes.github.io/blog/notes/articles-java-release-process-continuous-delivery/"/><meta property="og:type" content="article"/><meta property="article:published_time" content="10/6/2014"/><meta property="article:modified_time" content="4/26/2023"/><link rel="canonical" href="https://dustinbarnes.github.io/blog/notes/articles-java-release-process-continuous-delivery/"/><meta name="next-head-count" content="14"/><link rel="preload" href="/blog/_next/static/css/0884cc5025e90402.css" as="style"/><link rel="stylesheet" href="/blog/_next/static/css/0884cc5025e90402.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/blog/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/blog/_next/static/chunks/webpack-e6501809440c92fa.js" defer=""></script><script src="/blog/_next/static/chunks/framework-28c999baf2863c3d.js" defer=""></script><script src="/blog/_next/static/chunks/main-718fd100d66b9b0a.js" defer=""></script><script src="/blog/_next/static/chunks/pages/_app-db620eca7e43bfd8.js" defer=""></script><script src="/blog/_next/static/chunks/935-4dee79e80b8641c6.js" defer=""></script><script src="/blog/_next/static/chunks/6-50972def09142ee2.js" defer=""></script><script src="/blog/_next/static/chunks/pages/notes/%5Bid%5D-78d472fa3b924116.js" defer=""></script><script src="/blog/_next/static/e3auSERhnLAKuEr6XRDIR/_buildManifest.js" defer=""></script><script src="/blog/_next/static/e3auSERhnLAKuEr6XRDIR/_ssgManifest.js" defer=""></script></head><body><div id="__next" data-reactroot=""><section class="ant-layout" style="width:100%;min-height:100%"><header class="ant-layout-header" style="position:fixed;isolation:isolate;z-index:1;width:100%;border-bottom:1px solid #d4dadf;height:64px;padding:0 24px 0 2px"><div class="ant-row ant-row-center" style="max-width:992px;justify-content:space-between;margin:0 auto"><div style="display:flex" class="ant-col ant-col-xs-20 ant-col-sm-4"></div><div class="ant-col gutter-row ant-col-xs-0 ant-col-sm-20 ant-col-md-20 ant-col-lg-19"><div class="ant-select ant-select-lg ant-select-auto-complete ant-select-single ant-select-allow-clear ant-select-show-search" style="width:100%"><div class="ant-select-selector"><span class="ant-select-selection-search"><input type="search" autoComplete="off" class="ant-select-selection-search-input" role="combobox" aria-haspopup="listbox" aria-owns="undefined_list" aria-autocomplete="list" aria-controls="undefined_list" aria-activedescendant="undefined_list_0" value=""/></span><span class="ant-select-selection-placeholder">For full text search please use the &#x27;?&#x27; prefix. e.g. ? Onboarding</span></div></div></div><div style="display:none;align-items:center;justify-content:center" class="ant-col ant-col-xs-4 ant-col-sm-4 ant-col-md-0 ant-col-lg-0"><span role="img" aria-label="menu" style="font-size:24px" tabindex="-1" class="anticon anticon-menu"><svg viewBox="64 64 896 896" focusable="false" data-icon="menu" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M904 160H120c-4.4 0-8 3.6-8 8v64c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-64c0-4.4-3.6-8-8-8zm0 624H120c-4.4 0-8 3.6-8 8v64c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-64c0-4.4-3.6-8-8-8zm0-312H120c-4.4 0-8 3.6-8 8v64c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-64c0-4.4-3.6-8-8-8z"></path></svg></span></div></div></header><section class="ant-layout" style="margin-top:64px;display:flex;flex-direction:row"><div class="site-layout-sidebar" style="flex:0 0 auto;width:calc(max((100% - 992px) / 2, 0px) + 200px);min-width:200px;padding-left:calc((100% - 992px) / 2)"><aside class="ant-layout-sider ant-layout-sider-dark" style="position:fixed;overflow:auto;height:calc(100vh - 64px);background-color:transparent;flex:0 0 200px;max-width:200px;min-width:200px;width:200px"><div class="ant-layout-sider-children"></div></aside></div><main class="ant-layout-content side-layout-main" style="max-width:1200px;min-width:0;display:block"><div style="padding:0 24px"><div class="main-content" role="main"><div class="ant-row"><div class="ant-col ant-col-24"><div class="ant-row" style="margin-left:-10px;margin-right:-10px"><div style="padding-left:10px;padding-right:10px" class="ant-col ant-col-xs-24 ant-col-md-18"><div><h1 id="java-release-process-with-continuous-delivery">Java Release Process with Continuous Delivery<a aria-hidden="true" class="anchor-heading icon-link" href="#java-release-process-with-continuous-delivery"></a></h1>
<blockquote>
<p>This is a re-post of an article that is no longer hosted online. You can see it on the wayback machine at <a href="https://web.archive.org/web/20141221084323/http://www.dev9.com/blog/2014/9/java-release-process-with-continuous-delivery">https://web.archive.org/web/20141221084323/http://www.dev9.com/blog/2014/9/java-release-process-with-continuous-delivery</a></p>
</blockquote>
<h2 id="intro">Intro<a aria-hidden="true" class="anchor-heading icon-link" href="#intro"></a></h2>
<p>One of the most interesting things we deal with is releases. Not a deployment -- which is actually running the new software. A release, in our parlance, is creating a binary artifact at a specific and immutable version. In the Java world, most of us use Maven for releases. More pointedly, we use the <code>maven-release-plugin</code>. I am going to show you why you should stop using that plugin.</p>
<h2 id="why-change">Why Change?<a aria-hidden="true" class="anchor-heading icon-link" href="#why-change"></a></h2>
<p>This is a question I field a lot. There are several reasons, but the primary one is this: In a continuous delivery world, any commit could theoretically go to production. This means that you should be performing a maven release every time you build the software. So, let's revisit what happens inside your CI server when you use the maven-release-plugin properly:</p>
<ul>
<li>CI checks out the latest revision from SCM</li>
<li>Maven compiles the sources and runs the tests</li>
<li>Release Plugin transforms the POMs with the new non-SNAPSHOT version number</li>
<li>Maven compiles the sources and runs the tests</li>
<li>Release Plugin commits the new POMs into SCM</li>
<li>Release Plugin tags the new SCM revision with the version number</li>
<li>Release Plugin transforms the POMs to version n+1 -SNAPSHOT</li>
<li>Release Plugin commits the new new POMs into SCM</li>
<li>Release Plugin checks out the new tag from SCM</li>
<li>Maven compiles the sources and runs the tests</li>
<li>Maven publishes the binaries into the Artifact Repository</li>
</ul>
<p>Did you get all of that? It's <strong>3 full checkout/test cycles, 2 POM manipulations, and 3 SCM revisions</strong>. Not to mention, what happens when somebody commits a change to the pom.xml (say, to add a new dependency) in the middle of all this? It's not pretty.</p>
<p>The method we're going to propose has <strong>1 checkout/test cycle, 1 POM manipulation, and 1 SCM interaction</strong>. I don't know about you, but this seems significantly safer.</p>
<h2 id="versioning">Versioning<a aria-hidden="true" class="anchor-heading icon-link" href="#versioning"></a></h2>
<p>Before we get into the details, let's talk about versioning. Most organizations follow the versioning convention they see most frequently (often called Semantic Versioning or SEMVER), but don't follow the actual principles. The main idea behind this convention is that you have 3 version numbers in dotted notation <code>X.Y.Z</code>, where:</p>
<ul>
<li><code>X</code> is the major version. Any changes here are backwards-incompatible.</li>
<li><code>Y</code> is the minor version. Any changes here are backwards-compatible, but there may be bug fixes or new features.</li>
<li><code>Z</code> is the incremental version. All changes here are backwards-compatible.</li>
</ul>
<p>However, most organizations do not use these numbers correctly. How many apps have you seen that sit at 1.0.x despite drastic breaking changes, feature addition/removal, and more? This scheme provides little value, especially when most artifacts are used in-house only. So, what makes a good version number?</p>
<ul>
<li><em>Natural order</em>: it should be possible to determine at a glance between two versions which one is newer</li>
<li><em>Build tool support</em>: Maven should be able to deal with the format of the version number to enforce the natural order</li>
<li><em>Machine incrementable</em>: so you don't have to specify it explicitly every time</li>
</ul>
<p>While subversion offers a great candidate (the repository commit number), git does not have the same. However, all build systems, including both Bamboo and Jenkins, expose an environment variable that is the current build number. This is a perfect candidate that satisfies all three criteria, and has the added benefit that any artifact can be tied back to its specific build through convention.</p>
<h3 id="what-about-snapshots">What about Snapshots?<a aria-hidden="true" class="anchor-heading icon-link" href="#what-about-snapshots"></a></h3>
<p>Snapshots are an anti-pattern in continuous delivery. Snapshots are, by definition, ephemeral. However, we're making one exception, and that's in the POM file itself. The rule we're following is that the pom.xml always has the version <code>0-SNAPSHOT</code>. From here on out, no more snapshots!
The New Way</p>
<p>So, we're going to use the build number as the version number, and not have snapshots (except as described above). Our POM file is going to look a little something like this:</p>
<pre><code>&#x3C;project ...>
  ...
  &#x3C;version>0-SNAPSHOT&#x3C;/version>
&#x3C;/project>
</code></pre>
<p>This is the only time we will use <code>-SNAPSHOT</code> identifiers. Everything else will be explicitly versioned. I am assuming your distributionManagement and scm blocks are filled in correctly. Next, we need to add 2 plugins to our POM file:</p>
<pre><code>&#x3C;build>
    ...
    &#x3C;plugins>
    ...
        &#x3C;plugin>
            &#x3C;groupId>org.codehaus.mojo&#x3C;/groupId>
            &#x3C;artifactId>versions-maven-plugin&#x3C;/artifactId>
            &#x3C;version>2.1&#x3C;/version>
        &#x3C;/plugin>
        &#x3C;plugin>
            &#x3C;artifactId>maven-scm-plugin&#x3C;/artifactId>
            &#x3C;version>1.8.1&#x3C;/version>
            &#x3C;configuration>
                &#x3C;tag>${project.artifactId}-${project.version}&#x3C;/tag>
            &#x3C;/configuration>
        &#x3C;/plugin>
    &#x3C;/plugins>
&#x3C;/build>
</code></pre>
<p>The devil is in the details, of course, so let's see what should happen now during your release process. Note that I am using Bamboo in this example. You should make sure to modify it for your CI server's variables. The process is:</p>
<ol>
<li>CI checks out the latest revision from SCM</li>
<li>CI runs <code>mvn versions:set -DnewVersion=$ {bamboo.buildNumber}</code></li>
<li>Maven compiles the sources and runs the tests</li>
<li>Maven publishes the binaries into the Artifact Repository</li>
<li>Maven tags the version</li>
</ol>
<blockquote>
<p>Steps 3, 4, and 5 are run with one command: mvn deploy scm:tag.</p>
</blockquote>
<p>That's it. We have one specific revision being tagged for a release. Our history is cleaner, we can see exactly which revision/refs were used for a release, and it's immune to pom.xml changes being committed during the process. Much better!</p>
<h2 id="gotcha">Gotcha!<a aria-hidden="true" class="anchor-heading icon-link" href="#gotcha"></a></h2>
<p>Ok, this all works great, unless you have a bad setup. The primary culprit of a bad setup is distinct modules having snapshot dependencies. Remember how I told you snapshots are an anti-pattern? Here's the general rule: if the modules are part of the same build/release lifecycle, they should be put together in one source repository, and should be built/versioned/tagged/released as one unit. If the modules are completely separate, then they should be in a separate source repository, and you should have fixed-version dependencies between them to provide a consistent interface. If you are depending on snapshot versions, you are creating non-repeatable builds, as the time of day you run the build/release will determine which exact dependency you fetch. </p></div></div><div style="padding-left:10px;padding-right:10px" class="ant-col ant-col-xs-0 ant-col-md-6"><div><div class=""><div class="ant-anchor-wrapper dendron-toc" style="max-height:calc(100vh - 64px);z-index:1"><div class="ant-anchor"><div class="ant-anchor-ink"><span class="ant-anchor-ink-ball"></span></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#intro" title="Intro">Intro</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#why-change" title="Why Change?">Why Change?</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#versioning" title="Versioning">Versioning</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#what-about-snapshots" title="What about Snapshots?">What about Snapshots?</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#gotcha" title="Gotcha!">Gotcha!</a></div></div></div></div></div></div></div></div></div></div></div><div class="ant-divider ant-divider-horizontal" role="separator"></div><footer class="ant-layout-footer" style="padding:0 24px 24px"></footer></main></section></section></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"note":{"id":"articles-java-release-process-continuous-delivery","title":"Java Release Process with Continuous Delivery","desc":"","updated":1682481604985,"created":1412578800000,"custom":{},"fname":"articles.java-release-process-continuous-delivery","type":"note","vault":{"fsPath":".","selfContained":true,"name":"Dendron"},"contentHash":"25c94950bfc06250761794bdab7c1a61","links":[],"anchors":{"intro":{"type":"header","text":"Intro","value":"intro","line":10,"column":0,"depth":2},"why-change":{"type":"header","text":"Why Change?","value":"why-change","line":14,"column":0,"depth":2},"versioning":{"type":"header","text":"Versioning","value":"versioning","line":34,"column":0,"depth":2},"what-about-snapshots":{"type":"header","text":"What about Snapshots?","value":"what-about-snapshots","line":50,"column":0,"depth":3},"gotcha":{"type":"header","text":"Gotcha!","value":"gotcha","line":99,"column":0,"depth":2}},"children":[],"parent":"articles","data":{}},"body":"\u003ch1 id=\"java-release-process-with-continuous-delivery\"\u003eJava Release Process with Continuous Delivery\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#java-release-process-with-continuous-delivery\"\u003e\u003c/a\u003e\u003c/h1\u003e\n\u003cblockquote\u003e\n\u003cp\u003eThis is a re-post of an article that is no longer hosted online. You can see it on the wayback machine at \u003ca href=\"https://web.archive.org/web/20141221084323/http://www.dev9.com/blog/2014/9/java-release-process-with-continuous-delivery\"\u003ehttps://web.archive.org/web/20141221084323/http://www.dev9.com/blog/2014/9/java-release-process-with-continuous-delivery\u003c/a\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2 id=\"intro\"\u003eIntro\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#intro\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eOne of the most interesting things we deal with is releases. Not a deployment -- which is actually running the new software. A release, in our parlance, is creating a binary artifact at a specific and immutable version. In the Java world, most of us use Maven for releases. More pointedly, we use the \u003ccode\u003emaven-release-plugin\u003c/code\u003e. I am going to show you why you should stop using that plugin.\u003c/p\u003e\n\u003ch2 id=\"why-change\"\u003eWhy Change?\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#why-change\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eThis is a question I field a lot. There are several reasons, but the primary one is this: In a continuous delivery world, any commit could theoretically go to production. This means that you should be performing a maven release every time you build the software. So, let's revisit what happens inside your CI server when you use the maven-release-plugin properly:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eCI checks out the latest revision from SCM\u003c/li\u003e\n\u003cli\u003eMaven compiles the sources and runs the tests\u003c/li\u003e\n\u003cli\u003eRelease Plugin transforms the POMs with the new non-SNAPSHOT version number\u003c/li\u003e\n\u003cli\u003eMaven compiles the sources and runs the tests\u003c/li\u003e\n\u003cli\u003eRelease Plugin commits the new POMs into SCM\u003c/li\u003e\n\u003cli\u003eRelease Plugin tags the new SCM revision with the version number\u003c/li\u003e\n\u003cli\u003eRelease Plugin transforms the POMs to version n+1 -SNAPSHOT\u003c/li\u003e\n\u003cli\u003eRelease Plugin commits the new new POMs into SCM\u003c/li\u003e\n\u003cli\u003eRelease Plugin checks out the new tag from SCM\u003c/li\u003e\n\u003cli\u003eMaven compiles the sources and runs the tests\u003c/li\u003e\n\u003cli\u003eMaven publishes the binaries into the Artifact Repository\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eDid you get all of that? It's \u003cstrong\u003e3 full checkout/test cycles, 2 POM manipulations, and 3 SCM revisions\u003c/strong\u003e. Not to mention, what happens when somebody commits a change to the pom.xml (say, to add a new dependency) in the middle of all this? It's not pretty.\u003c/p\u003e\n\u003cp\u003eThe method we're going to propose has \u003cstrong\u003e1 checkout/test cycle, 1 POM manipulation, and 1 SCM interaction\u003c/strong\u003e. I don't know about you, but this seems significantly safer.\u003c/p\u003e\n\u003ch2 id=\"versioning\"\u003eVersioning\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#versioning\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eBefore we get into the details, let's talk about versioning. Most organizations follow the versioning convention they see most frequently (often called Semantic Versioning or SEMVER), but don't follow the actual principles. The main idea behind this convention is that you have 3 version numbers in dotted notation \u003ccode\u003eX.Y.Z\u003c/code\u003e, where:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eX\u003c/code\u003e is the major version. Any changes here are backwards-incompatible.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eY\u003c/code\u003e is the minor version. Any changes here are backwards-compatible, but there may be bug fixes or new features.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eZ\u003c/code\u003e is the incremental version. All changes here are backwards-compatible.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eHowever, most organizations do not use these numbers correctly. How many apps have you seen that sit at 1.0.x despite drastic breaking changes, feature addition/removal, and more? This scheme provides little value, especially when most artifacts are used in-house only. So, what makes a good version number?\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cem\u003eNatural order\u003c/em\u003e: it should be possible to determine at a glance between two versions which one is newer\u003c/li\u003e\n\u003cli\u003e\u003cem\u003eBuild tool support\u003c/em\u003e: Maven should be able to deal with the format of the version number to enforce the natural order\u003c/li\u003e\n\u003cli\u003e\u003cem\u003eMachine incrementable\u003c/em\u003e: so you don't have to specify it explicitly every time\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eWhile subversion offers a great candidate (the repository commit number), git does not have the same. However, all build systems, including both Bamboo and Jenkins, expose an environment variable that is the current build number. This is a perfect candidate that satisfies all three criteria, and has the added benefit that any artifact can be tied back to its specific build through convention.\u003c/p\u003e\n\u003ch3 id=\"what-about-snapshots\"\u003eWhat about Snapshots?\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#what-about-snapshots\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eSnapshots are an anti-pattern in continuous delivery. Snapshots are, by definition, ephemeral. However, we're making one exception, and that's in the POM file itself. The rule we're following is that the pom.xml always has the version \u003ccode\u003e0-SNAPSHOT\u003c/code\u003e. From here on out, no more snapshots!\nThe New Way\u003c/p\u003e\n\u003cp\u003eSo, we're going to use the build number as the version number, and not have snapshots (except as described above). Our POM file is going to look a little something like this:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u0026#x3C;project ...\u003e\n  ...\n  \u0026#x3C;version\u003e0-SNAPSHOT\u0026#x3C;/version\u003e\n\u0026#x3C;/project\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis is the only time we will use \u003ccode\u003e-SNAPSHOT\u003c/code\u003e identifiers. Everything else will be explicitly versioned. I am assuming your distributionManagement and scm blocks are filled in correctly. Next, we need to add 2 plugins to our POM file:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u0026#x3C;build\u003e\n    ...\n    \u0026#x3C;plugins\u003e\n    ...\n        \u0026#x3C;plugin\u003e\n            \u0026#x3C;groupId\u003eorg.codehaus.mojo\u0026#x3C;/groupId\u003e\n            \u0026#x3C;artifactId\u003eversions-maven-plugin\u0026#x3C;/artifactId\u003e\n            \u0026#x3C;version\u003e2.1\u0026#x3C;/version\u003e\n        \u0026#x3C;/plugin\u003e\n        \u0026#x3C;plugin\u003e\n            \u0026#x3C;artifactId\u003emaven-scm-plugin\u0026#x3C;/artifactId\u003e\n            \u0026#x3C;version\u003e1.8.1\u0026#x3C;/version\u003e\n            \u0026#x3C;configuration\u003e\n                \u0026#x3C;tag\u003e${project.artifactId}-${project.version}\u0026#x3C;/tag\u003e\n            \u0026#x3C;/configuration\u003e\n        \u0026#x3C;/plugin\u003e\n    \u0026#x3C;/plugins\u003e\n\u0026#x3C;/build\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe devil is in the details, of course, so let's see what should happen now during your release process. Note that I am using Bamboo in this example. You should make sure to modify it for your CI server's variables. The process is:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eCI checks out the latest revision from SCM\u003c/li\u003e\n\u003cli\u003eCI runs \u003ccode\u003emvn versions:set -DnewVersion=$ {bamboo.buildNumber}\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003eMaven compiles the sources and runs the tests\u003c/li\u003e\n\u003cli\u003eMaven publishes the binaries into the Artifact Repository\u003c/li\u003e\n\u003cli\u003eMaven tags the version\u003c/li\u003e\n\u003c/ol\u003e\n\u003cblockquote\u003e\n\u003cp\u003eSteps 3, 4, and 5 are run with one command: mvn deploy scm:tag.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eThat's it. We have one specific revision being tagged for a release. Our history is cleaner, we can see exactly which revision/refs were used for a release, and it's immune to pom.xml changes being committed during the process. Much better!\u003c/p\u003e\n\u003ch2 id=\"gotcha\"\u003eGotcha!\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#gotcha\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eOk, this all works great, unless you have a bad setup. The primary culprit of a bad setup is distinct modules having snapshot dependencies. Remember how I told you snapshots are an anti-pattern? Here's the general rule: if the modules are part of the same build/release lifecycle, they should be put together in one source repository, and should be built/versioned/tagged/released as one unit. If the modules are completely separate, then they should be in a separate source repository, and you should have fixed-version dependencies between them to provide a consistent interface. If you are depending on snapshot versions, you are creating non-repeatable builds, as the time of day you run the build/release will determine which exact dependency you fetch. \u003c/p\u003e","noteIndex":{"id":"root","title":"Dustin Barnes","desc":"","updated":1681759798693,"created":1595961348801,"custom":{"nav_order":0,"permalink":"/"},"fname":"root","type":"note","vault":{"fsPath":".","selfContained":true,"name":"Dendron"},"contentHash":"3ebb4073bdee31751a155bb33051029a","links":[],"anchors":{"dustin-barnes":{"type":"header","text":"Dustin Barnes","value":"dustin-barnes","line":8,"column":0,"depth":1}},"children":["articles","concepts","xufh3s1pjwin0pvew6jmu8j"],"parent":null,"data":{},"body":"\n# Dustin Barnes\n\nThis is my digital garden. It's not monetized, there's no analytics. It's probably not great at SEO. But it's simple, it's text-based, and it's interconnected. \n\nA few things of note: \n\n- My main GitHub profile is https://github.com/dustinbarnes\n- This blog is built from https://github.com/dustinbarnes/blog. \n  - Notice the GitHub Actions powering the publish process: https://github.com/dustinbarnes/blog/blob/main/.github/workflows/publish.yml\n- My dotfiles repo: https://github.com/dustinbarnes/dotfiles\n"},"collectionChildren":null,"customHeadContent":null,"config":{"version":5,"dev":{"enablePreviewV2":true,"enableSelfContainedVaults":true},"commands":{"lookup":{"note":{"selectionMode":"extract","confirmVaultOnCreate":true,"vaultSelectionModeOnCreate":"smart","leaveTrace":false,"bubbleUpCreateNew":true,"fuzzThreshold":0.2}},"randomNote":{},"insertNoteLink":{"aliasMode":"none","enableMultiSelect":false},"insertNoteIndex":{"enableMarker":false},"copyNoteLink":{"aliasMode":"title"},"templateHierarchy":"template"},"workspace":{"vaults":[{"fsPath":".","selfContained":true,"name":"Dendron"}],"journal":{"dailyDomain":"daily","name":"journal","dateFormat":"y.MM.dd","addBehavior":"childOfDomain"},"scratch":{"name":"scratch","dateFormat":"y.MM.dd.HHmmss","addBehavior":"asOwnDomain"},"task":{"name":"task","dateFormat":"y.MM.dd","addBehavior":"asOwnDomain","statusSymbols":{"":" ","wip":"w","done":"x","assigned":"a","moved":"m","blocked":"b","delegated":"l","dropped":"d","pending":"y"},"taskCompleteStatus":["done","x"],"prioritySymbols":{"H":"high","M":"medium","L":"low"},"todoIntegration":false,"createTaskSelectionType":"selection2link"},"graph":{"zoomSpeed":1,"createStub":false},"enableAutoCreateOnDefinition":false,"enableXVaultWikiLink":false,"enableRemoteVaultInit":true,"enableUserTags":true,"enableHashTags":true,"workspaceVaultSyncMode":"noCommit","enableAutoFoldFrontmatter":false,"enableEditorDecorations":true,"maxPreviewsCached":10,"maxNoteLength":204800,"enableFullHierarchyNoteTitle":false},"preview":{"enableFMTitle":true,"enableNoteTitleForLink":true,"enableFrontmatterTags":true,"enableHashesForFMTags":false,"enablePrettyRefs":true,"enableKatex":true,"automaticallyShowPreview":false},"publishing":{"enableFMTitle":true,"enableNoteTitleForLink":true,"enablePrettyRefs":true,"enableKatex":true,"copyAssets":true,"siteHierarchies":["root"],"writeStubs":false,"siteRootDir":"docs","seo":{"title":"Dustin Barnes","description":"Personal Knowledge Space"},"github":{"enableEditLink":true,"editLinkText":"Edit this page on GitHub","editBranch":"main","editViewMode":"tree"},"enableSiteLastModified":true,"enableFrontmatterTags":true,"enableHashesForFMTags":false,"enableRandomlyColoredTags":true,"enableTaskNotes":true,"enablePrettyLinks":true,"searchMode":"search","siteUrl":"https://dustinbarnes.github.io","assetsPrefix":"/blog","siteFaviconPath":"favicon.ico","siteIndex":"root"}}},"__N_SSG":true},"page":"/notes/[id]","query":{"id":"articles-java-release-process-continuous-delivery"},"buildId":"e3auSERhnLAKuEr6XRDIR","assetPrefix":"/blog","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>